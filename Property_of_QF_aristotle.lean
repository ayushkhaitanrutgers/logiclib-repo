/-
This file was generated by Aristotle.

Lean Toolchain version: leanprover/lean4:v4.20.0-rc5
Mathlib version: d62eab0cc36ea522904895389c301cf8d844fd69 (May 9, 2025)
-/

/-
This module proves that quantifier-free formulas are preserved under substructures (embeddings).
Specifically, if `M` is a substructure of `N` (represented by an embedding `f : M ↪[L] N`) and `φ` is a quantifier-free formula,
then `φ` is true in `M` under a valuation `v` if and only if it is true in `N` under the valuation `f ∘ v`.

The main theorem is `realize_quantifierFree_of_embedding`.
The proof proceeds by induction on the structure of the quantifier-free formula `φ`.
1. It first establishes that embeddings preserve the evaluation of terms.
2. Then it shows the result for atomic formulas (equalities and relations) using the properties of embeddings.
3. Finally, it extends the result to boolean combinations (negation and conjunction) using the inductive hypothesis.
-/

import Mathlib

/-
  open scoped BigOperators
  open scoped Real
  open scoped Nat
  open scoped Classical
  open scoped Pointwise
-/
set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open FirstOrder FirstOrder.Language

variable {L : Language} {M N : Type*} [L.Structure M] [L.Structure N]
variable (f : M ↪[L] N)

theorem realize_quantifierFree_of_embedding {α : Type*} (φ : L.Formula α) (hφ : φ.IsQF) (v : α → M) :
    φ.Realize v ↔ φ.Realize (f ∘ v) := by
  revert φ v;
  intro φ hφ
  induction' hφ with φ hφ ih;
  · aesop;
  · cases hφ ; aesop;
    · simp_all +decide [ FirstOrder.Language.Formula.Realize ];
      -- Since $f$ is an embedding, it preserves the realization of terms. Therefore, if the realizations of $t₁$ and $t₂$ under $v$ are equal, then applying $f$ to both sides gives the equality under $f \circ v$.
      have h_realize : ∀ (t : L.Term (α ⊕ Fin 0)) (v : α → M), FirstOrder.Language.Term.realize (Sum.elim ((⇑f : M → N) ∘ v) Inhabited.default) t = f (FirstOrder.Language.Term.realize (Sum.elim v Inhabited.default) t) := by
        intro t v; induction t <;> aesop;
        exact Fin.elim0 val_1;
      rw [ h_realize t₁ v, h_realize t₂ v, a ];
    · rw [ FirstOrder.Language.Formula.Realize ] at *;
      convert a using 1;
      simp +decide [ FirstOrder.Language.BoundedFormula.Realize ];
      -- Since $f$ is an embedding, it preserves the interpretation of terms.
      have h_term : ∀ (t : L.Term (α ⊕ Fin 0)) (v : α → M), FirstOrder.Language.Term.realize (Sum.elim ((⇑f : M → N) ∘ v) Inhabited.default) t = f (FirstOrder.Language.Term.realize (Sum.elim v Inhabited.default) t) := by
        intro t v; induction t <;> aesop;
        exact Fin.elim0 val_1;
      rw [ h_term t₁ v, h_term t₂ v, f.injective.eq_iff ];
    · intro v; simp +decide [ FirstOrder.Language.Formula.Realize ] ;
      -- Since $f$ is an embedding, it preserves the interpretation of terms.
      have h_term : ∀ (t : FirstOrder.Language.Term L (α ⊕ Fin 0)) (v : α → M), FirstOrder.Language.Term.realize (Sum.elim ((⇑f : M → N) ∘ v) Inhabited.default) t = f (FirstOrder.Language.Term.realize (Sum.elim v Inhabited.default) t) := by
        intro t v; induction t <;> aesop;
        exact Fin.elim0 val_1;
      simp +decide [ h_term ];
      rw [ ← f.map_rel ];
      rfl;
  · simp_all +decide [ FirstOrder.Language.Formula.Realize ]
