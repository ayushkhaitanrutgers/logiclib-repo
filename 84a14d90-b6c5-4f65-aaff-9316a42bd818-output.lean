/-
This file was generated by Aristotle.

Lean Toolchain version: leanprover/lean4:v4.20.0-rc5
Mathlib version: d62eab0cc36ea522904895389c301cf8d844fd69 (May 9, 2025)
-/

/-
This module defines Quantifier Elimination and Model Completeness in First-Order Logic and proves that a theory with Quantifier Elimination is Model Complete. It also includes a lemma stating that quantifier-free formulas are preserved under embeddings.
[Mathias]: This file states and proves a relevant result that is not yet in Mathlib, though it is not the result I asked for
This was generated by the prompt version of aristotle, asking it to autoformalize the results in "QE_test.tex",
using the results of "Property_of_QF.lean" as input. The first statement here is a reproduction of the content of "Property_of_QF.lean"
-/

import Mathlib
/- [Mathias]: it seems that opening these causes errors when writing φ
open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise
-/
set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check FirstOrder.Language
#check FirstOrder.Language.Formula
#check FirstOrder.Language.Theory

#check FirstOrder.Language.BoundedFormula
#check FirstOrder.Language.BoundedFormula.IsQF
#check FirstOrder.Language.BoundedFormula.Realize
#check FirstOrder.Language.Theory.Model

#print prefix FirstOrder.Language.Theory
#print prefix FirstOrder.Language.BoundedFormula

open FirstOrder FirstOrder.Language FirstOrder.Language.Theory

universe u v w

variable {L : FirstOrder.Language.{u, v}}

def FormulasEquivalent (T : L.Theory) {n} (φ ψ : L.BoundedFormula Empty n) : Prop :=
  ∀ {M : Type w} [L.Structure M] [Nonempty M], M ⊨ T →
    ∀ (v : Fin n → M), φ.Realize Empty.elim v ↔ ψ.Realize Empty.elim v

def HasQuantifierElimination (T : L.Theory) : Prop :=
  ∀ {n} (φ : L.BoundedFormula Empty n), ∃ (ψ : L.BoundedFormula Empty n),
    ψ.IsQF ∧ FormulasEquivalent.{u, v, w} T φ ψ

def IsModelComplete (T : L.Theory) : Prop :=
  ∀ {M : Type w} {N : Type w} [L.Structure M] [L.Structure N] [Nonempty M] [Nonempty N],
    M ⊨ T → N ⊨ T → ∀ (f : L.Embedding M N),
      ∀ {n} (φ : L.BoundedFormula Empty n) (v : Fin n → M),
        φ.Realize Empty.elim v ↔ φ.Realize Empty.elim (f ∘ v)

theorem realize_qf_of_embedding {M : Type w} {N : Type w} [L.Structure M] [L.Structure N]
    (f : L.Embedding M N) {n} {φ : L.BoundedFormula Empty n}
    (hφ : φ.IsQF) {v : Fin n → M} :
    φ.Realize Empty.elim v ↔ φ.Realize Empty.elim (f ∘ v) := by
  -- By definition of embedding, the realization of atomic formulas is preserved.
  have h_atomic : ∀ (φ : L.BoundedFormula Empty n), φ.IsAtomic → ∀ (v : Fin n → M), φ.Realize Empty.elim v ↔ φ.Realize Empty.elim (f ∘ v) := by
    intro φ hφ v;
    cases hφ;
    · -- Since the terms are in the empty type, they must be constants. The realization of a constant term is just the constant itself.
      have h_const : ∀ (t : L.Term (Empty ⊕ Fin n)), ∃ c : M, FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) t = c ∧ FirstOrder.Language.Term.realize (Sum.elim Empty.elim (f ∘ v)) t = f c := by
        intro t; induction t <;> aesop;
      obtain ⟨ c₁, hc₁, hc₁' ⟩ := h_const ‹_›; obtain ⟨ c₂, hc₂, hc₂' ⟩ := h_const ‹_›; aesop;
    · -- Since $f$ is an embedding, it preserves the realization of terms.
      have h_term : ∀ (t : L.Term (Empty ⊕ Fin n)) (v : Fin n → M), FirstOrder.Language.Term.realize (Sum.elim Empty.elim (f ∘ v)) t = f (FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) t) := by
        intro t v; induction t <;> aesop;
      aesop;
      · convert a using 1;
        exact f.map_rel R _;
      · exact?;
  induction hφ <;> aesop

theorem qe_implies_model_complete (T : L.Theory) (h : HasQuantifierElimination.{u, v, w} T) :
    IsModelComplete.{u, v, w} T := by
  -- Assume T has quantifier elimination.
  unfold HasQuantifierElimination at h
  simp_all +decide [ IsModelComplete ];
  intro M N _ _ a b hM hN f n φ v; specialize h φ; aesop;
  · unfold FormulasEquivalent at right; aesop;
    have := @right M _ a hM v; have := @right N _ b hN ( f ∘ v ) ; aesop;
    exact?;
  · simp_all +decide [ FormulasEquivalent ];
    have := @right M _ a hM ( fun i => v i ) ; have := @right N _ b hN ( fun i => f ( v i ) ) ; aesop;
    have h_equiv : ∀ {w : L.BoundedFormula Empty n}, w.IsQF → ∀ {v : Fin n → M}, w.Realize Empty.elim v ↔ w.Realize Empty.elim (f ∘ v) := by
      intros w hw v; induction hw <;> aesop;
      · cases h <;> aesop;
        · have h_term_eq : ∀ {t : L.Term (Empty ⊕ Fin n)}, FirstOrder.Language.Term.realize (Sum.elim Empty.elim ((⇑f : M → N) ∘ v)) t = f (FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) t) := by
            intro t; induction t <;> aesop;
          aesop;
        · convert f.map_rel R _;
          -- Since $f$ is an embedding, it preserves the structure, so the realization of the term $ts i$ in $M$ is equal to the realization of the term $ts i$ in $N$ with the variables replaced by $f \circ v$.
          have h_realize : ∀ (t : L.Term (Empty ⊕ Fin n)), FirstOrder.Language.Term.realize (Sum.elim Empty.elim ((⇑f : M → N) ∘ v)) t = f (FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) t) := by
            intro t; induction t <;> aesop;
          simp +decide only [h_realize];
          swap;
          exact fun i => FirstOrder.Language.Term.realize ( Sum.elim Empty.elim v ) ( ts i );
          bound;
          convert a_3.mpr a_2 using 1;
      · cases h ; aesop;
        · -- Since $f$ is an embedding, it preserves the realization of terms.
          have h_term_realize : ∀ (t : L.Term (Empty ⊕ Fin n)) (v : Fin n → M), FirstOrder.Language.Term.realize (Sum.elim Empty.elim ((⇑f : M → N) ∘ v)) t = f (FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) t) := by
            intro t v; induction t <;> aesop;
          aesop;
        · -- Since $f$ is an embedding, it preserves the structure, so the realization of the term in $M$ is equal to the realization in $N$ when composed with $f$.
          have h_embedding : ∀ (t : L.Term (Empty ⊕ Fin n)), FirstOrder.Language.Term.realize (Sum.elim Empty.elim ((⇑f : M → N) ∘ v)) t = f (FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) t) := by
            intro t; induction t <;> aesop;
          aesop;
          exact?;
    specialize @h_equiv w left ; aesop;
    tauto
