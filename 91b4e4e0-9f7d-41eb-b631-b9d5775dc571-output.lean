/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean Toolchain version: leanprover/lean4:v4.20.0-rc5
Mathlib version: d62eab0cc36ea522904895389c301cf8d844fd69 (May 9, 2025)
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#print FirstOrder.Language.Structure
#check FirstOrder.Language.BoundedFormula
#check FirstOrder.Language.Theory

open FirstOrder
open FirstOrder.Language

abbrev L_ab_Functions (n : ℕ) : Type :=
  match n with
  | 0 => Unit
  | 1 => Unit
  | 2 => Unit
  | _ => Empty

abbrev L_ab_Relations (n : ℕ) : Type := Empty

def L_ab : Language := Language.mk L_ab_Functions L_ab_Relations

instance {G : Type*} [AddCommGroup G] : L_ab.Structure G where
  funMap := fun {n} f =>
    match n, f with
    | 0, _ => fun _ => 0
    | 1, _ => fun x => - (x 0)
    | 2, _ => fun x => (x 0) + (x 1)
    | n+3, f' => Empty.elim f'
  RelMap := fun {n} r => Empty.elim r

open FirstOrder
open FirstOrder.Language

def DAG : Theory L_ab :=
  { φ | ∀ (G : Type) [AddCommGroup G] [Module ℚ G] [Nontrivial G], G ⊨ φ }

def HasQuantifierElimination (L : Language) (T : Theory L) : Prop :=
  ∀ (n : ℕ) (φ : L.BoundedFormula Empty n),
  ∃ (ψ : L.BoundedFormula Empty n), ψ.IsQF ∧
  ∀ (M : Type) [L.Structure M] [Nonempty M], M ⊨ T →
  ∀ (v : Fin n → M), φ.Realize Empty.elim v ↔ ψ.Realize Empty.elim v

open FirstOrder
open FirstOrder.Language

lemma term_realize_embedding {L : Language} {M N : Type} [L.Structure M] [L.Structure N]
  (f : M →[L] N) (n : ℕ) (t : L.Term (Empty ⊕ Fin n)) (v : Fin n → M) :
  Term.realize (Sum.elim Empty.elim (f ∘ v)) t = f (Term.realize (Sum.elim Empty.elim v) t) := by
    -- We proceed by induction on the structure of the term `t`.
    induction' t with t ih;
    · cases t <;> aesop;
    · -- By the properties of the homomorphism $f$ and the induction hypothesis, we can conclude that the realization of the function application commutes with $f$.
      simp [FirstOrder.Language.Term.realize, *];
      rfl


#print FirstOrder.Language.Embedding
#check FirstOrder.Language.Hom
#check FirstOrder.Language.Hom.map_rel

open FirstOrder
open FirstOrder.Language

lemma qf_preserved_under_embedding {L : Language} {M N : Type} [L.Structure M] [L.Structure N]
  (f : M ↪[L] N) (n : ℕ) (φ : L.BoundedFormula Empty n) (hφ : φ.IsQF) (v : Fin n → M) :
  φ.Realize Empty.elim v ↔ φ.Realize Empty.elim (f ∘ v) := by
    induction' φ with _ _ ih1 ih2 ; aesop;
    · simp +decide [ FirstOrder.Language.BoundedFormula.Realize ];
      -- Since $f$ is an embedding, it preserves the values of the variables and the functions.
      have h_realize : ∀ (t : L.Term (Empty ⊕ Fin _)), FirstOrder.Language.Term.realize (Sum.elim Empty.elim ((⇑f : M → N) ∘ v)) t = f (FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) t) := by
        -- By induction on the structure of the term t, we can show that the realization under f ∘ v is f applied to the realization under v.
        intro t
        induction' t with t ih;
        · cases t <;> aesop;
        · aesop;
      aesop;
    · unfold FirstOrder.Language.BoundedFormula.Realize; aesop;
      · convert a using 1;
        -- By definition of embedding, we know that $f$ preserves the relations.
        have h_rel : ∀ (x : Fin l → M), (FirstOrder.Language.Structure.RelMap R (f ∘ x)) ↔ (FirstOrder.Language.Structure.RelMap R x) := by
          exact?;
        -- By definition of embedding, we know that $f$ preserves the structure, so applying $f$ to each term is the same as applying $f$ to the entire function.
        have h_term_realize : ∀ (i : Fin l), FirstOrder.Language.Term.realize (Sum.elim Empty.elim ((⇑f : M → N) ∘ v)) (ts i) = f (FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) (ts i)) := by
          -- By definition of embedding, we know that $f$ preserves the structure, so applying $f$ to each term is the same as applying $f$ to the entire function. We can prove this by induction on the structure of the term $t$.
          have h_term_realize : ∀ (t : L.Term (Empty ⊕ Fin n_1)), FirstOrder.Language.Term.realize (Sum.elim Empty.elim ((⇑f : M → N) ∘ v)) t = f (FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) t) := by
            bound;
            induction t <;> aesop;
          exact fun i => h_term_realize _;
        convert h_rel _ using 2 ; aesop;
      · -- Since $f$ is an embedding, it preserves the realization of terms.
        have h_term_realize : ∀ (t : L.Term (Empty ⊕ Fin n_1)) (v : Fin n_1 → M), FirstOrder.Language.Term.realize (Sum.elim Empty.elim (f ∘ v)) t = f (FirstOrder.Language.Term.realize (Sum.elim Empty.elim v) t) := by
          -- By definition of term realization, we can prove this by induction on the term t.
          intro t v; induction' t with t ih; aesop;
          aesop;
        aesop;
        exact?;
    · -- By the induction hypotheses, we know that the realizations of f₁ and f₂ are preserved under the embedding f.
      have h_f1 : ∀ (v : Fin _ → M), (‹L.BoundedFormula Empty _›).Realize Empty.elim v ↔ (‹L.BoundedFormula Empty _›).Realize Empty.elim (f ∘ v) := by
        cases hφ ; aesop;
        · cases h;
        · cases h;
        · solve_by_elim
      have h_f2 : ∀ (v : Fin _ → M), (‹L.BoundedFormula Empty _›).Realize Empty.elim v ↔ (‹L.BoundedFormula Empty _›).Realize Empty.elim (f ∘ v) := by
        assumption;
      aesop;
      · convert a _;
        exact f₁_ih ( by cases hφ <;> tauto ) v |>.2 a_1;
      · exact a ( f₁_ih ( by cases hφ <;> tauto ) v |>.1 a_1 );
    · cases hφ;
      cases ‹_›


#check qf_preserved_under_embedding

open FirstOrder
open FirstOrder.Language

lemma qe_of_exists_qe {L : Language} {T : Theory L}
  (h : ∀ (n : ℕ) (φ : L.BoundedFormula Empty (n+1)), φ.IsQF →
    ∃ (ψ : L.BoundedFormula Empty n), ψ.IsQF ∧
    ∀ (M : Type) [L.Structure M] [Nonempty M], M ⊨ T →
    ∀ (v : Fin n → M), ((∃ x : M, φ.Realize Empty.elim (Fin.snoc v x)) ↔ ψ.Realize Empty.elim v)) :
  HasQuantifierElimination L T := by
    -- Apply the induction hypothesis to the formula φ.
    intro n φ
    induction' φ with n φ ih;
    · exact ⟨ ⊥, by tauto, by tauto ⟩;
    · exact ⟨ FirstOrder.Language.BoundedFormula.equal ih ‹_›, by tauto, by tauto ⟩;
    · -- Since R is a relation symbol and ts are terms, the formula R(ts) is already quantifier-free.
      use FirstOrder.Language.BoundedFormula.rel ‹_› ‹_›; simp [FirstOrder.Language.BoundedFormula.IsQF];
      constructor;
      -- Since R(ts) is a relation applied to terms, it is atomic by definition.
      apply FirstOrder.Language.BoundedFormula.IsAtomic.rel;
    · bound;
      use w.imp w_1;
      simp +zetaDelta at *;
      exact ⟨ by exact?, fun M _ a ha v => by specialize right M a ha v; specialize right_1 M a ha v; aesop ⟩;
    · rename_i k hk;
      obtain ⟨ ψ, hψ₁, hψ₂ ⟩ := hk;
      obtain ⟨ ψ', hψ'₁, hψ'₂ ⟩ := h _ ( ψ.not ) ( by
        exact? );
      use ψ'.not;
      norm_num +zetaDelta at *;
      bound;
      · exact?;
      · contrapose! hψ'₂;
        exact ⟨ M, inst, a, a_1, v, Or.inr ⟨ fun x => by simpa [ hψ₂ M a a_1 ] using a_2 x, a_3 ⟩ ⟩;
      · specialize hψ₂ M a a_1 ( Fin.snoc v a_3 ) ; specialize hψ'₂ M a a_1 v ; aesop


open FirstOrder
open FirstOrder.Language

lemma qf_preserved_embedding {L : Language} {M N : Type} [L.Structure M] [L.Structure N]
  (f : M ↪[L] N) (n : ℕ) (φ : L.BoundedFormula Empty n) (hφ : φ.IsQF) (v : Fin n → M) :
  φ.Realize Empty.elim v ↔ φ.Realize Empty.elim (f ∘ v) := by
    exact?


#check TensorProduct
#check TensorProduct.tmul
#check Module
#check AddCommGroup

open FirstOrder
open FirstOrder.Language

lemma tensor_product_elem_representation {A : Type*} [AddCommGroup A] (x : TensorProduct ℤ ℚ A) :
  ∃ (n : ℤ) (a : A), n ≠ 0 ∧ n • x = (1 : ℚ) ⊗ₜ[ℤ] a := by
    induction' x using TensorProduct.induction_on with x y;
    · exact ⟨ 1, 0, by norm_num, by simp +decide ⟩;
    · -- Since $x$ is a rational number, we can write it as $x = \frac{p}{q}$ where $p$ and $q$ are integers and $q \neq 0$.
      obtain ⟨p, q, hq, hx⟩ : ∃ p q : ℤ, q ≠ 0 ∧ x = p / q := by
        exact ⟨ x.num, x.den, Nat.cast_ne_zero.mpr x.pos.ne', x.num_div_den.symm ⟩;
      refine' ⟨ q, p • y, hq, _ ⟩ ; simp +decide [ hx, div_eq_mul_inv, mul_assoc, mul_left_comm, TensorProduct.tmul_smul, hq ];
      simp +decide [ hq, mul_left_comm ( q : ℚ ), TensorProduct.smul_tmul', TensorProduct.tmul_smul ];
    · simp +zetaDelta at *;
      rename_i hx hy;
      -- Let $n = n_x \cdot n_y$ and $a = n_y \cdot a_x + n_x \cdot a_y$.
      obtain ⟨n_x, hn_x, a_x, hx⟩ := hx
      obtain ⟨n_y, hn_y, a_y, hy⟩ := hy
      use n_x * n_y, by
        aesop, n_y • a_x + n_x • a_y;
      convert congr_arg₂ ( · + · ) ( congr_arg ( fun z => n_y • z ) hx ) ( congr_arg ( fun z => n_x • z ) hy ) using 1;
      · -- By the associativity of scalar multiplication in the tensor product, we have:
        simp [mul_comm, mul_assoc, smul_smul];
      · simp +decide [ TensorProduct.tmul_add, TensorProduct.smul_tmul' ]